name: Test Kubernetes / Helm Install

on:
  pull_request:
    branches:
      - main
      - develop

jobs:
  install-helm-charts:
    runs-on: ubuntu-latest
    services:
      # Runs a local Docker registry accessible at localhost:5000
      registry:
        image: registry:2
        ports:
          - 5000:5000
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Start minikube
        uses: medyagh/setup-minikube@latest

      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Create Namespace
        run: kubectl create namespace tradestream-namespace

      - name: Create Secrets
        run: |
          kubectl create secret generic \
            coinmarketcap \
            --from-literal=apiKey=FAKE_API_KEY \
            --namespace=tradestream-namespace

      - uses: bazel-contrib/setup-bazel@0.9.1
        with:
          # Avoid downloading Bazel every time
          bazelisk-cache: true
          # Store build cache per workflow
          disk-cache: ${{ github.workflow }}
          # Share repository cache between workflows
          repository-cache: true

      - name: Build and Push the Data Ingestion Image
        run: |
          # Push to local registry
          bazel run //src/main/java/com/verlumen/tradestream/ingestion:push_image \
            --verbose_failures \
            --sandbox_debug \
            -- \
            --repository localhost:5000/tradestream-data-ingestion \
            --tag "latest"

      - name: Build and Push the Strategy Engine Image
        run: |
          # Push to local registry
          bazel run //src/main/java/com/verlumen/tradestream/strategies:push_image \
            --verbose_failures \
            --sandbox_debug \
            -- \
            --repository localhost:5000/tradestream-strategy-engine \
            --tag "latest"

      - name: Pull Images into Local Docker Daemon
        run: |
          # Pull the images from the local registry into the local Docker daemon
          docker pull localhost:5000/tradestream-data-ingestion:latest
          docker pull localhost:5000/tradestream-strategy-engine:latest

          # Retag the images to remove the registry prefix, so Kubernetes doesn't try to pull them remotely
          docker tag localhost:5000/tradestream-data-ingestion:latest tradestream-data-ingestion:latest
          docker tag localhost:5000/tradestream-strategy-engine:latest tradestream-strategy-engine:latest

      - name: Load Images into Minikube
        run: |
          # Load the retagged images into Minikube's image cache
          minikube image load tradestream-data-ingestion:latest
          minikube image load tradestream-strategy-engine:latest

      - name: Install TradeStream Helm Chart
        run: |
          helm dependency update charts/tradestream && \
          helm install my-tradestream charts/tradestream \
            --namespace tradestream-namespace \
            --set strategyEngine.image.repository=tradestream-strategy-engine \
            --set strategyEngine.image.tag=latest \
            --set 'strategyEngine.args[0]=--runMode=dry' \
            --set dataIngestion.image.repository=tradestream-data-ingestion \
            --set dataIngestion.image.tag=latest \
            --set 'dataIngestion.args[0]=--runMode=dry'

      - name: Wait for All Pods to be Ready
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status

          namespace="tradestream-namespace"
          timeout_seconds=180
          interval=10  # Interval between checks in seconds
          end_time=$((SECONDS+timeout_seconds))

          echo "Waiting for pods in namespace '${namespace}' to become Ready (timeout: ${timeout_seconds}s)..."

          while [ $SECONDS -lt $end_time ]; do
            # Use kubectl wait with a short timeout for this iteration
            if kubectl wait --for=condition=Ready pod --all -n "${namespace}" --timeout="${interval}s" 2>/dev/null; then
              echo "All pods in namespace '${namespace}' are Ready."
              exit 0
            fi

            # If we're here, some pods aren't ready yet
            echo "Current pod statuses in namespace '${namespace}':"
            kubectl get pods -n "${namespace}"

            # Only show detailed status if we're close to timeout
            time_left=$((end_time-SECONDS))
            if [ $time_left -lt $((interval * 2)) ]; then
              echo -e "\nGathering detailed status and logs for non-ready pods..."

              # Get pods where the 'Ready' condition status is 'False'
              not_ready_pod_names=$(kubectl get pods -n "${namespace}" -o jsonpath='{range .items[?(@.status.conditions[?(@.type=="Ready")].status=="False")]}{.metadata.name}{"\n"}{end}')

              if [[ -n "$not_ready_pod_names" ]]; then
                while IFS= read -r pod; do
                  echo -e "\nDetails for pod '$pod':"
                  kubectl describe pod "$pod" -n "${namespace}"

                  # Get container statuses
                  containers=$(kubectl get pod "$pod" -n "${namespace}" -o jsonpath='{.spec.containers[*].name}')
                  if [[ -n "$containers" ]]; then
                    for container in $containers; do
                      echo -e "\nLogs for container '$container' in pod '$pod':"
                      # Try to get previous logs first
                      kubectl logs "$pod" -n "${namespace}" -c "$container" --previous 2>/dev/null || true
                      # Get current logs
                      kubectl logs "$pod" -n "${namespace}" -c "$container"
                    done
                  fi
                done <<< "$not_ready_pod_names"
              fi
            else
              echo "Waiting ${interval} seconds before next check... (${time_left}s until timeout)"
            fi
            sleep $interval
          done

          echo "Timeout reached while waiting for pods to be ready."
          echo -e "\nFinal pod statuses in namespace '${namespace}':"
          kubectl get pods -n "${namespace}"

          # Final detailed status for failed pods
          echo -e "\nGathering final detailed status and logs for non-ready pods..."
          not_ready_pod_names=$(kubectl get pods -n "${namespace}" -o jsonpath='{range .items[?(@.status.conditions[?(@.type=="Ready")].status=="False")]}{.metadata.name}{"\n"}{end}')

          if [[ -n "$not_ready_pod_names" ]]; then
            while IFS= read -r pod; do
              echo -e "\nDetails for pod '$pod':"
              kubectl describe pod "$pod" -n "${namespace}"

              containers=$(kubectl get pod "$pod" -n "${namespace}" -o jsonpath='{.spec.containers[*].name}')
              if [[ -n "$containers" ]]; then
                for container in $containers; do
                  echo -e "\nLogs for container '$container' in pod '$pod':"
                  kubectl logs "$pod" -n "${namespace}" -c "$container" --previous 2>/dev/null || true
                  kubectl logs "$pod" -n "${namespace}" -c "$container"
                done
              fi
            done <<< "$not_ready_pod_names"
          fi

          exit 1

      - name: Verify Installations
        run: |
          kubectl get pods -n tradestream-namespace
