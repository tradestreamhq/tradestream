influxdb:
  enabled: true
  # Authentication configuration
  adminUser:
    # Organization and bucket settings
    organization: "tradestream-org"
    bucket: "tradestream-data"
    retention_policy: "30d"
    # User credentials - these should be strings, not objects
    # username: "admin"       # Use username, not user
    # password: "your-secure-password"  # Direct string, not nested

    # Or use existing secret (comment out username/password if using this)
    existingSecret: "influxdb-admin-secret"
    # Token configuration - should be a string or boolean
    token: true # Set to true to auto-generate, or provide a specific token string
  # Storage configuration
  persistence:
    enabled: true
    size: 8Gi
  service:
    type: ClusterIP
kafka:
  replicaCount: 3
  persistence:
    enabled: true
    size: 10Gi
    accessModes:
      - ReadWriteOnce
  listeners:
    client:
      protocol: PLAINTEXT
    controller:
      protocol: PLAINTEXT
  configurationOverrides:
    "controller.quorum.voters": "0@kafka-0.kafka-headless:9093,1@kafka-1.kafka-headless:9093,2@kafka-2.kafka-headless:9093"
  podSecurityContext:
    runAsUser: 1001
    fsGroup: 1001
  resources:
    requests:
      cpu: "1"
      memory: "2Gi"
    limits:
      cpu: "2"
      memory: "4Gi"
kafkaUi:
  replicaCount: 1
  image:
    repository: provectuslabs/kafka-ui
    tag: latest
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 8080
pipeline:
  runMode: wet
  image:
    repository: tradestreamhq/tradestream-data-pipeline
    tag: v1.31.1-develop
    pullPolicy: IfNotPresent
  version: v1_18
  configuration:
    env.java.opts.jobmanager: "-Dio.jenetics.util.defaultRandomGenerator=Random"
    env.java.opts.taskmanager: "-Dio.jenetics.util.defaultRandomGenerator=Random"
    taskmanager.numberOfTaskSlots: "1"
    execution.checkpointing.interval: "300000"
    execution.checkpointing.mode: "EXACTLY_ONCE"
    execution.checkpointing.timeout: "1800000"
    execution.checkpointing.externalized-checkpoint-retention: "RETAIN_ON_CANCELLATION"
    state.backend: "rocksdb"
    state.backend.incremental: "true"
  serviceAccount: flink
  jobManager:
    memory: 4096m
    cpu: 2
  taskManager:
    memory: 4096m
    cpu: 2
  job:
    entryClass: com.verlumen.tradestream.pipeline.App
    jarURI: local:///src/main/java/com/verlumen/tradestream/pipeline/app_deploy.jar
    parallelism: 1
    upgradeMode: stateless

candleIngestor:
  enabled: false
  replicaCount: 1
  image:
    repository: "your-docker-repo/candle-ingestor" # TODO: Replace with actual image repo
    pullPolicy: IfNotPresent
    # tag: "" # Defaults to .Chart.AppVersion, will be overridden by CI/CD
  serviceAccount:
    create: true
    # name: "" # Defaults to <helm-release-name>-candle-ingestor, uncomment to override
    annotations: {}
  config:
    topNCryptos: 100
    candleGranularityMinutes: 1
    influxDbUrl: "http://{{ include "tradestream.fullname" . }}-influxdb:8086" # Assumes InfluxDB is deployed by the same chart
    influxDbBucket: "tradestream-data" # Should match the bucket created by the InfluxDB sub-chart
    dataSources: "coinmarketcap,tiingo" # Comma-separated list of data sources
    # Add other script-specific flags here
    # exampleFlag: "exampleValue"
  secrets:
    # Secrets for API keys
    cmcApiKey:
      name: "coinmarketcap" # Name of the existing K8s secret for CoinMarketCap
      key: "apiKey"        # Key within the secret that holds the API key
    tiingoApiKey:
      name: "tiingo"       # Name of the existing K8s secret for Tiingo
      key: "apiKey"        # Key within the secret that holds the API key
    # New secret for InfluxDB application token specific to the candle ingestor
    influxDb:
      name: "influxdb-candle-ingestor-credentials" # Name of the new K8s secret to be created
      tokenKey: "INFLUXDB_TOKEN" # Key for the InfluxDB token
      orgKey: "INFLUXDB_ORG"     # Key for the InfluxDB organization
  # Resource requests and limits
  resources: {}
  #   requests:
  #     cpu: 100m
  #     memory: 128Mi
  #   limits:
  #     cpu: 500m
  #     memory: 512Mi

  # Liveness probe configuration
  livenessProbe:
    exec:
      command:
      - /bin/true # Placeholder: Replace with actual health check command if available
    initialDelaySeconds: 30 # How long to wait after the container starts before performing the first probe
    periodSeconds: 15       # How often to perform the probe
    timeoutSeconds: 5       # When the probe times out
    failureThreshold: 3     # Number of times Kubernetes will try when a Pod fails a Liveness Probe
    successThreshold: 1     # Minimum consecutive successes for the probe to be considered successful after having failed

  # Readiness probe configuration
  readinessProbe:
    exec:
      command:
      - /bin/true # Placeholder: Replace with actual health check command if available
    initialDelaySeconds: 30 # How long to wait after the container starts before performing the first probe
    periodSeconds: 15       # How often to perform the probe
    timeoutSeconds: 5       # When the probe times out
    failureThreshold: 3     # Number of times Kubernetes will try when a Pod fails a Readiness Probe
    successThreshold: 1     # Minimum consecutive successes for the probe to be considered successful after having failed
